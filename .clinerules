# AI-Nx-Starter Claude Code Rules

## Project Overview
AI-Nx-Starter is an Nx monorepo with Angular frontend and NestJS backend, designed for AI-assisted development.

## Architecture

### Package Structure
```
@ai-nx-starter/types          - Shared TypeScript types and DTOs
@ai-nx-starter/api-client     - Auto-generated Angular HTTP services
@ai-nx-starter/backend-common - Shared backend utilities
@ai-nx-starter/data-access-layer - Database entities and services
```

### Import Rules
ALWAYS use workspace aliases:
```typescript
import { UserDto } from '@ai-nx-starter/types';
import { ApiUserService } from '@ai-nx-starter/api-client';
import { UserDbService } from '@ai-nx-starter/data-access-layer';
```

NEVER use relative paths to packages:
```typescript
// âŒ WRONG
import { UserDto } from '../../../packages/types/src/dto/user.dto';
```

## Documentation Resources

**IMPORTANT:** Before starting any task, consult the relevant documentation:

- **`/prompts/`** - AI prompt templates for common tasks (CRUD, endpoints, UI, tests, etc.)
  - Read the relevant prompt BEFORE starting to ensure you follow all requirements
- **`/documents/`** - Technical reference docs (API reference, architecture, auth model, etc.)
  - Consult when you need to understand patterns or implementation details
- **`CLAUDE.md`** - Quick reference guide (always read first)
- **`.clinerules`** - This file (comprehensive rules and standards)

## Backend Rules (NestJS)

### Architecture Layers
1. **Controller**: HTTP endpoints, validation, authorization, Swagger documentation
2. **Service**: Business logic
3. **Mapper**: Entity â†” DTO transformation
4. **DbService**: Database operations (in data-access-layer)

### Key Constraints
- NEVER import TypeORM directly in web-server
- ALWAYS use data-access-layer services for database operations
- DTOs MUST be in @ai-nx-starter/types package
- Use class-validator decorators in all DTOs (NEVER @ApiProperty)
- Swagger decorators ONLY in controllers (@ApiOperation, @ApiResponse, @ApiParam, @ApiQuery, @ApiBody, @ApiBearerAuth)
- Use @Authorize() decorator for protected endpoints
- ALL endpoints MUST have Swagger documentation
- ALL functionality MUST have unit tests (>80% coverage)

### Naming Conventions
- Controllers: `[Feature]Controller`
- Services: `[Feature]Service`
- Mappers: `[Feature]Mapper`
- DbServices: `[Entity]DbService`

### File Organization
```
apps/web-server/src/app/features/[feature]/
â”œâ”€â”€ [feature].controller.ts
â”œâ”€â”€ [feature].service.ts
â”œâ”€â”€ [feature].mapper.ts
â””â”€â”€ [feature].module.ts
```

## Frontend Rules (Angular)

### Component Organization
```
apps/web-ui/src/app/features/[feature]/[component-name]/
â”œâ”€â”€ [component-name].component.ts
â”œâ”€â”€ [component-name].component.html
â”œâ”€â”€ [component-name].component.less
â””â”€â”€ [component-name].component.spec.ts
```

### Naming Conventions
- Components: `[feature]-[type].component.ts` (kebab-case)
- Services: `[feature].service.ts`
- Use OnPush change detection
- Use reactive forms

### UI Framework
- Use NG-ZORRO components exclusively
- Follow theme in `apps/web-ui/src/assets/styles/theme.less`
- Avoid inline styles
- Use LESS for styling

### API Integration
- ALWAYS use auto-generated services from @ai-nx-starter/api-client
- NEVER create manual HTTP calls
- If API client is outdated, remind to run: `npm run gen-api-client`

## Data Access Layer

### Entity Rules
- Location: `packages/data-access-layer/src/features/[entity]/entities/`
- Use TypeORM decorators
- Match DTOs from @ai-nx-starter/types

### DbService Rules
- Location: `packages/data-access-layer/src/features/[entity]/services/`
- Name: `[Entity]DbService`
- Provide CRUD operations
- Handle database errors

## API Client Generation

### When to Run
Run `npm run gen-api-client` after:
- Creating new controllers
- Modifying controller endpoints
- Changing parameter types
- Adding/removing routes

### What It Does
- Scans all `*.controller.ts` files
- Generates Angular services in `packages/api-client/src/api/`
- Updates exports in `packages/api-client/src/index.ts`
- Creates type-safe HTTP methods

## Development Workflow

### Creating CRUD Features

**ðŸ“– See `prompts/create-crud-feature.md` for complete step-by-step guide**

1. Create DTOs in `packages/types/src/dto/` (class-validator ONLY, NO @ApiProperty)
2. Create Entity in `packages/data-access-layer/`
3. Create DbService in `packages/data-access-layer/`
4. Create Controller/Service/Mapper in `apps/web-server/`
   - **REQUIRED:** Add Swagger decorators to ALL endpoints (ðŸ“– see `prompts/document-api-endpoint.md`)
   - **REQUIRED:** Write unit tests (*.spec.ts) (ðŸ“– see `prompts/generate-tests.md`)
5. Run `npm run test` - Verify all tests pass
6. Run `npm run gen-api-client`
7. Create UI components in `apps/web-ui/` (ðŸ“– see `prompts/create-ui-component.md`)
8. Run `npm run build` after each step
9. Verify Swagger UI at http://localhost:3030/api/docs

### Testing
- Run `npm run build` frequently
- Run `npm run test` after writing tests
- Fix errors incrementally
- Verify TypeScript types
- Aim for >80% test coverage

## Common Patterns

### Controller Example
```typescript
@ApiTags('Users')
@ApiBearerAuth('bearer')
@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @ApiOperation({ summary: 'Get all users', description: 'Retrieve list with pagination' })
  @ApiQuery({ name: 'limit', required: false, example: 10 })
  @ApiResponse({ status: 200, description: 'Success', type: [UserDto] })
  @ApiResponse({ status: 401, description: 'Not authenticated' })
  @ApiResponse({ status: 403, description: 'Insufficient permissions' })
  @Authorize(Role.Admin)
  @Get()
  findAll(): Promise<UserDto[]> {
    return this.userService.findAll();
  }
}
```

### Service Example
```typescript
@Injectable()
export class UserService {
  constructor(
    private readonly userDbService: UserDbService,
    private readonly userMapper: UserMapper
  ) {}

  async findAll(): Promise<UserDto[]> {
    const entities = await this.userDbService.findAll();
    return entities.map(e => this.userMapper.toDto(e));
  }
}
```

### Component Example
```typescript
@Component({
  selector: 'app-user-list',
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class UserListComponent {
  users$ = this.apiUserService.findAll();

  constructor(private apiUserService: ApiUserService) {}
}
```

## Error Handling

### Backend
- Use custom exceptions from @ai-nx-starter/backend-common
- Throw AppError, AppWarning, or NotImplementedException
- Let global exception filter handle responses

### Frontend
- Use MessageService for user feedback
- Handle errors in subscribe error callback
- Show loading states with *ngIf="loading"

## Documentation

### Code Comments
- Add JSDoc to public methods
- Document complex logic
- Explain non-obvious decisions

### README Updates
After significant changes, update:
- README.md
- AI-DEVELOPMENT.md
- Relevant docs in documents/

## Validation

### Backend DTOs
```typescript
export class CreateUserDto {
  @IsString()
  @MinLength(3)
  name: string;

  @IsEmail()
  email: string;

  @IsOptional()
  @IsEnum(Role)
  role?: Role;
}
```

### Frontend Forms
- Use reactive forms
- Add validators
- Show error messages with nz-form-control

## Build and Deploy

### Build Command
```bash
npm run build
```

### Production Build
```bash
npm run build:prod
```

### Docker
```bash
./build-docker.sh
```

## API Documentation & Testing

### API Documentation (Swagger/OpenAPI)
- ALL endpoints MUST have Swagger decorators
- DTOs NEVER use @ApiProperty (use class-validator only)
- Swagger decorators ONLY in controllers
- Verify at http://localhost:3030/api/docs
- See `prompts/document-api-endpoint.md` for templates

### Unit Testing Requirements
- ALL new functionality MUST have unit tests
- Test controllers, services, mappers, DbServices
- Aim for >80% coverage
- Use `jest.fn()` for mocks
- Run `npm run test` before committing
- See `prompts/generate-tests.md` for templates

## Reminders

- Run `npm run gen-api-client` after backend changes
- Use `npm run build` to verify changes
- Run `npm run test` before committing
- Follow existing patterns - check examples/ folder
- Keep DTOs in sync between backend and database
- Consult `/prompts/` templates before starting tasks
- Use descriptive commit messages
